/////////////////////////////////////////////////////////////////////////////
// Name:        videopreviewframe.cpp
// Purpose:     
// Author:      
// Modified by: 
// Created:     07/09/2018 14:48:49
// RCS-ID:      
// Copyright:   
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (unregistered), 07/09/2018 14:48:49

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include "videopreviewframe.h"
#include "../../model/remote_file_model.h"
#include "../../model/user_model.h"
////@begin XPM images
////@end XPM images
#ifdef U
#undef U
#include <boost/format.hpp>
#include <boost/lexical_cast.hpp>
#ifdef U
#undef U
#endif
#define U(x) _XPLATSTR(x)
#endif
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 * VideoPreviewFrame type definition
 */

IMPLEMENT_DYNAMIC_CLASS(VideoPreviewFrame, wxDialog)


/*
 * VideoPreviewFrame event table definition
 */

	BEGIN_EVENT_TABLE(VideoPreviewFrame, wxDialog)

	////@begin VideoPreviewFrame event table entries
	EVT_CLOSE(VideoPreviewFrame::OnCloseWindow)

	////@end VideoPreviewFrame event table entries

	END_EVENT_TABLE()


	/*
	 * VideoPreviewFrame constructors
	 */

	static void wakeup(void *ctx)
	{
		// This callback is invoked from any mpv thread (but possibly also
		// recursively from a thread that is calling the mpv API). Just notify
		// the Qt GUI thread to wake up (so that it can process events with
		// mpv_wait_event()), and return as quickly as possible.
		VideoPreviewFrame *mainwindow = (VideoPreviewFrame *)ctx;
		//mainwindow->CheckTimer();
		wxThreadEvent event(wxEVT_THREAD);
		//auto ts = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
		//event.SetTimestamp(ts);
		//event.SetId(this->GetId());
		event.SetInt(VIDEO_PLAYER_WAKEUP);
		//event.SetPayload(v);
		//std::cout << "Tick0" << std::endl;
		wxQueueEvent(mainwindow, event.Clone());
	}


VideoPreviewFrame::VideoPreviewFrame()
{
	Init();
}

VideoPreviewFrame::VideoPreviewFrame(const utility::string_t &path, wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style)
{
	Init();
	Create(parent, id, caption, pos, size, style);
	ctx = mpv_create();
	//this->time.StartTimer(200, [&] {this->CheckTimer(); });
	printLog(_XPLATSTR("Preview file: ") + path);
	if (ctx == nullptr) {
		printLog(_XPLATSTR("Create player failed. "));
	}
	else {

		printLog(_XPLATSTR("Create player success. "));
		mpv_set_option_string(ctx, "title",utility::conversions::to_utf8string(path).c_str());
		mpv_set_option_string(ctx, "force-media-title", utility::conversions::to_utf8string(path).c_str());
		RemoteFileModel::Instance().GetPreviewInfo(this, path);
	}
	
}


/*
 * VideoPreviewFrame creator
 */

bool VideoPreviewFrame::Create(wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style)
{
	////@begin VideoPreviewFrame creation
	SetExtraStyle(wxWS_EX_VALIDATE_RECURSIVELY | wxWS_EX_BLOCK_EVENTS);
	wxDialog::Create(parent, id, caption, pos, size, style);

	CreateControls();
	Centre();
	////@end VideoPreviewFrame creation
	return true;
}


/*
 * VideoPreviewFrame destructor
 */

VideoPreviewFrame::~VideoPreviewFrame()
{
	////@begin VideoPreviewFrame destruction

	////@end VideoPreviewFrame destruction
}


/*
 * Member initialisation
 */

void VideoPreviewFrame::Init()
{
	////@begin VideoPreviewFrame member initialisation
	////@end VideoPreviewFrame member initialisation
}


/*
 * Control creation for VideoPreviewFrame
 */

void VideoPreviewFrame::CreateControls()
{
	////@begin VideoPreviewFrame content construction
	// Generated by DialogBlocks, 27/09/2018 12:56:55 (unregistered)

	VideoPreviewFrame* itemDialog1 = this;

	wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
	itemDialog1->SetSizer(itemBoxSizer2);

	wxPanel* itemPanel1 = new wxPanel(itemDialog1, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSUNKEN_BORDER | wxTAB_TRAVERSAL);
	itemPanel1->SetExtraStyle(wxWS_EX_VALIDATE_RECURSIVELY);
	itemPanel1->SetName(wxT("playerPanel"));
	itemBoxSizer2->Add(itemPanel1, 1, wxGROW, 5);

	wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxHORIZONTAL);
	itemPanel1->SetSizer(itemBoxSizer3);

	logTextCtrl = new wxTextCtrl(itemPanel1, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_MULTILINE);
	logTextCtrl->SetEditable(false);
	itemBoxSizer3->Add(logTextCtrl, 1, wxGROW, 5);

	wxBoxSizer* itemBoxSizer4 = new wxBoxSizer(wxHORIZONTAL);
	itemBoxSizer2->Add(itemBoxSizer4, 0, wxGROW, 5);

	wxStaticText* itemStaticText1 = new wxStaticText(itemDialog1, wxID_STATIC, _("Subtitle"), wxDefaultPosition, wxDefaultSize, 0);
	itemBoxSizer4->Add(itemStaticText1, 0, wxALIGN_CENTER_VERTICAL | wxALL, 5);

	wxArrayString itemChoice5Strings;
	wxChoice* itemChoice5 = new wxChoice(itemDialog1, wxID_ANY, wxDefaultPosition, wxDefaultSize, itemChoice5Strings, 0);
	itemBoxSizer4->Add(itemChoice5, 1, wxALIGN_CENTER_VERTICAL | wxALL, 5);

	wxButton* itemButton1 = new wxButton(itemDialog1, wxID_ANY, _("Manage"), wxDefaultPosition, wxDefaultSize, 0);
	itemBoxSizer4->Add(itemButton1, 0, wxALIGN_CENTER_VERTICAL | wxALL, 5);

	wxArrayString itemChoice7Strings;
	wxChoice* itemChoice7 = new wxChoice(itemDialog1, wxID_ANY, wxDefaultPosition, wxSize(80, -1), itemChoice7Strings, 0);
	itemBoxSizer4->Add(itemChoice7, 0, wxALIGN_CENTER_VERTICAL | wxALL, 5);
	this->Bind(wxEVT_THREAD, &VideoPreviewFrame::OnThreadEvent, this);
	////@end VideoPreviewFrame content construction
	
}


/*
 * Should we show tooltips?
 */

bool VideoPreviewFrame::ShowToolTips()
{
	return true;
}

void VideoPreviewFrame::OnThreadEvent(wxThreadEvent & event)
{
	switch (event.GetInt()) {
		case VIDEO_LOG_MESSAGE:
			this->logTextCtrl->AppendText(event.GetString() + _XPLATSTR("\n"));
			this->logTextCtrl->LineDown();
			break;
		case VIDEO_PLAYER_WAKEUP:
			//this->CheckTimer();
			//mpv_wakeup(ctx);
			while (ctx) {
				mpv_event *eventx = mpv_wait_event(ctx, 0);
				if (eventx->event_id == MPV_EVENT_NONE)
					break;
				//handle_mpv_event(event);
				//std::cout << "HANDLE_WAKEUP" << std::endl;
				//mpv_event *eventX = mpv_wait_event(ctx, 0);
				if (eventx->event_id == MPV_EVENT_SHUTDOWN) {
					closing = true;
					mpv_detach_destroy(ctx);
					ctx = nullptr;
					this->Close();
				}
				if (!closing) {
					this->logTextCtrl->AppendText(utility::conversions::to_string_t(mpv_event_name(eventx->event_id)) + _XPLATSTR("\n"));
					this->logTextCtrl->LineDown();
				}
				
			}
			break;
	case USER_PREVIEW_INFO:
	{
		auto payload = event.GetPayload<ResponseEntity>();
		//RefreshListData(payload);
		if (payload.success) {
			//wxMessageBox(_("Success load preview file."), _("Load Preview Success"));
			
			if (payload.result.has_field(U("preview"))) {
				auto preview = payload.result.at(U("preview")).as_array();
				if (preview.size() > 0) {
					// do preview
					
					
					printLog(wxString::Format(_("Get preview size: %lld "), preview.size()));
					PlayPreview(preview);
				}
				else {
					wxMessageBox(_("Preview file is empty."), _("Load Preview Error"));
					this->Close();
				}
			}
		}
		else {

			wxMessageBox(_("Cannot load preview file."), _("Load Preview Error"));
			this->Close();
		}
		break;
	}
	default:
		event.Skip();
	}
}

void VideoPreviewFrame::printLog(utility::string_t log)
{
	/*
	this->CallAfter([&]{
		this->logTextCtrl->AppendText(log + _XPLATSTR("\n"));
		this->logTextCtrl->LineDown();
	});
	 */
	wxThreadEvent event(wxEVT_THREAD);
	auto ts = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
	event.SetTimestamp(ts);
	//event.SetId(this->GetId());
	event.SetInt(VIDEO_LOG_MESSAGE);
	event.SetString(log);
	//event.SetPayload(v);
	//std::cout << "Tick0" << std::endl;
	wxQueueEvent(this, event.Clone());

}



void VideoPreviewFrame::PlayPreview(const web::json::array & array)
{
	int clear = 0;
	utility::string_t t;
	int idx = 0;
	for (const auto& i : array) {
		auto c = i.at(U("clear")).as_integer();
		printLog(wxString::Format(wxT("Preview: %d : %s") , idx , i.at(U("resolution")).as_string()));
		if (c > clear) {
			t = i.at(U("url")).as_string();
			clear = c;
			
			//printLog(utility::conversions::to_string_t((boost::format(" : %1% ")).str()));
			idx++;
			//
			//printLog(utility::conversions::to_string_t((boost::format(" : %1% ") % i).str()));
		}
	}
	if (clear > 0) {
		auto url = t.append(U("?token=")).append(UserModel::Instance().GetToken());
		const std::string& playUrl = utility::conversions::to_utf8string(url);
		//auto system = wxPlatformInfo::Get().GetOperatingSystemId();
		printLog(_XPLATSTR("Starting media player..."));
		mpv_set_option_string(ctx, "input-default-bindings", "yes");
		mpv_set_option_string(ctx, "input-vo-keyboard", "yes");
		mpv_set_option_string(ctx, "keep-open", "yes");
        mpv_set_option_string(ctx, "on-top", "yes");
        mpv_set_option_string(ctx, "on-top-level", "system");
		//keep-open
		int val = 1;
		mpv_set_option(ctx, "osc", MPV_FORMAT_FLAG, &val);
		mpv_set_wakeup_callback(ctx, wakeup, this);
		// Done setting up options.
		mpv_initialize(ctx);
		const std::string& xx = utility::conversions::to_utf8string(url);
		// Play this file.
		const char *cmd[] = { "loadfile", xx.c_str(), nullptr };
		mpv_command(ctx, cmd);
		//instance =
		/*
		mpv_handle *ctx = mpv_create();
		if (!ctx) {
			printLog(_XPLATSTR("failed creating context"));
			return;
		}
		mpv_set_option_string(ctx, "input-default-bindings", "yes");
		mpv_set_option_string(ctx, "input-vo-keyboard", "yes");
		mpv_set_option_string(ctx, "keep-open", "yes");
		int val = 1;
		mpv_set_option(ctx, "osc", MPV_FORMAT_FLAG, &val);
		mpv_initialize(ctx);
		
		printLog(url);
		const char *cmd[] = { "loadfile", xx.data(), NULL };
		while (1) {
			mpv_event *event = mpv_wait_event(ctx, 10000);
			printLog( _XPLATSTR("event: ") + utility::conversions::to_string_t(mpv_event_name(event->event_id)));
			if (event->event_id == MPV_EVENT_SHUTDOWN)
				break;
			if (event->event_id == MPV_EVENT_IDLE)
				break;
		}*/

		//mpv_terminate_destroy(ctx);
	}
	else {
		//wxMessageBox(_("No video stream found."), _("Load Preview Error"));
		this->Close();
	}
}




/*
 * Get bitmap resources
 */

wxBitmap VideoPreviewFrame::GetBitmapResource(const wxString& name)
{
	// Bitmap retrieval
////@begin VideoPreviewFrame bitmap retrieval
	wxUnusedVar(name);
	return wxNullBitmap;
	////@end VideoPreviewFrame bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon VideoPreviewFrame::GetIconResource(const wxString& name)
{
	// Icon retrieval
////@begin VideoPreviewFrame icon retrieval
	wxUnusedVar(name);
	return wxNullIcon;
	////@end VideoPreviewFrame icon retrieval
}


/*
 * wxEVT_CLOSE_WINDOW event handler for ID_VIDEOPREVIEWFRAME
 */

void VideoPreviewFrame::OnCloseWindow(wxCloseEvent& event)
{
	closing = true;
	////@begin wxEVT_CLOSE_WINDOW event handler for ID_VIDEOPREVIEWFRAME in VideoPreviewFrame.
		// Before editing this code, remove the block markers.
	//wxMessageBox(_(""));
	//time.Expire();
	if (ctx != nullptr) {
		//mpv_terminate_destroy(ctx);
		//ctx = nullptr;
		//this->CallAfter([&] {this->Close(true); });
		//mpv_command()
		const char *cmd[] = { "quit", nullptr };
		mpv_command(ctx,cmd);
		//mpv_detach_destroy(ctx);
		return;
		//this->CallAfter([&] {time.Expire(); ctx = nullptr; this->Close(); });
	}
	event.Skip();
	//this->Destroy();


	wxThreadEvent closeEvt(wxEVT_THREAD);
	//auto ts = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
	//event.SetTimestamp(ts);
	//event.SetId(this->GetId());
	closeEvt.SetInt(VIDEO_PREVIEW_FRAME_CLOSE);
	//event.SetString(log);
	//event.SetPayload(v);
	//std::cout << "Tick0" << std::endl;
	if(emitEvent){
		wxQueueEvent(this->GetParent(), closeEvt.Clone());
	}


	//this->Close();
	////@end wxEVT_CLOSE_WINDOW event handler for ID_VIDEOPREVIEWFRAME in VideoPreviewFrame. 
}

void VideoPreviewFrame::CloseInner() {
	emitEvent = false;
	this->Close();
}


/*
 * wxEVT_SCROLL_PAGEUP event handler for ID_SLIDER
 */


